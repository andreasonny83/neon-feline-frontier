<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Neon Feline Frontier - Local Host</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!--
        IMPORTANT: This script tag requires your local server to be running.
        The '/socket.io/socket.io.js' path is automatically served by the
        Socket.io server instance in server.js.
    -->
    <script src="/socket.io/socket.io.js"></script>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: #0f0a1e;
        color: white;
        font-family: 'Courier New', Courier, monospace;
        touch-action: none;
      }
      #gameCanvas {
        display: block;
        position: absolute;
        top: 0;
        left: 0;
        z-index: 1;
      }
      #ui-layer {
        position: absolute;
        top: 20px;
        left: 20px;
        pointer-events: none;
        z-index: 50; /* High z-index to stay above canvas */
      }
      #chat-container {
        position: absolute;
        top: 20px;
        right: 20px;
        width: 300px;
        pointer-events: auto;
        display: flex;
        flex-direction: column;
        gap: 10px;
        z-index: 100; /* Ensure this is on top of everything */
      }
      .retro-panel {
        background: rgba(15, 10, 30, 0.9);
        border: 2px solid #ff00de;
        padding: 12px;
        box-shadow:
          0 0 15px #ff00de,
          inset 0 0 10px rgba(255, 0, 222, 0.3);
        backdrop-filter: blur(8px);
      }
      .retro-text {
        text-shadow: 2px 2px #ff00de;
        font-weight: bold;
        letter-spacing: 2px;
      }
      .retro-btn {
        background: rgba(0, 243, 255, 0.1);
        border: 1px solid #00f3ff;
        color: #00f3ff;
        padding: 6px 12px;
        cursor: pointer;
        font-family: inherit;
        font-weight: bold;
        text-transform: uppercase;
        transition: all 0.2s;
        text-shadow: 0 0 5px #00f3ff;
      }
      .retro-btn:hover {
        background: #00f3ff;
        color: #000;
        box-shadow: 0 0 15px #00f3ff;
      }
      .retro-input {
        background: rgba(0, 0, 0, 0.7);
        border: 1px solid #ff00de;
        color: white;
        padding: 8px;
        width: 100%;
        font-family: inherit;
        outline: none;
      }
      .retro-input:focus {
        border-color: #00f3ff;
        box-shadow: 0 0 5px #00f3ff;
      }
      #chat-messages {
        font-size: 12px;
        color: #00ff99;
        height: 180px;
        overflow-y: auto;
        margin-bottom: 8px;
        padding-right: 5px;
        display: flex;
        flex-direction: column;
        gap: 6px;
        scrollbar-width: thin;
        scrollbar-color: #ff00de transparent;
      }
      /* Custom scrollbar for webkit */
      #chat-messages::-webkit-scrollbar {
        width: 4px;
      }
      #chat-messages::-webkit-scrollbar-thumb {
        background: #ff00de;
      }
      #scoreboard-list::-webkit-scrollbar {
        width: 4px;
      }
      #scoreboard-list::-webkit-scrollbar-thumb {
        background: #ff00de;
      }
      .scoreboard-entry {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 4px 6px;
        margin-bottom: 4px;
        background: rgba(0, 0, 0, 0.3);
        border-left: 2px solid rgba(0, 243, 255, 0.3);
        font-size: 11px;
      }
      .scoreboard-entry.highlight {
        background: rgba(0, 243, 255, 0.2);
        border-left-color: #00f3ff;
        box-shadow: 0 0 8px rgba(0, 243, 255, 0.4);
      }
      .scoreboard-rank {
        color: #ffcc00;
        font-weight: bold;
        margin-right: 6px;
        min-width: 20px;
      }
      .scoreboard-name {
        flex: 1;
        color: #00ff99;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }
      .scoreboard-score {
        color: #ff00de;
        font-weight: bold;
        margin-left: 8px;
      }

      .chat-msg {
        word-wrap: break-word;
        line-height: 1.4;
        border-left: 2px solid rgba(0, 255, 153, 0.3);
        padding-left: 6px;
      }
      #mobile-controls {
        display: none;
        position: absolute;
        bottom: 40px;
        left: 40px;
        width: 150px;
        height: 150px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 50%;
        touch-action: none;
        pointer-events: auto;
        z-index: 60;
      }
      #joystick {
        position: absolute;
        top: 50%;
        left: 50%;
        width: 50px;
        height: 50px;
        background: rgba(0, 243, 255, 0.5);
        border-radius: 50%;
        transform: translate(-50%, -50%);
        pointer-events: none;
      }
      #minimap-container {
        position: absolute;
        bottom: 20px;
        right: 20px;
        width: 150px;
        height: 150px;
        border: 2px solid #00f3ff;
        background: rgba(15, 10, 30, 0.8);
        box-shadow: 0 0 10px #00f3ff;
        pointer-events: none;
        z-index: 60;
        /* display: none; */
      }
      #minimapCanvas {
        width: 100%;
        height: 100%;
      }
      @media (max-width: 768px) {
        #mobile-controls {
          display: block;
        }
        #chat-container {
          width: 240px;
          top: 10px;
          right: 10px;
        }
        #minimap-container {
          bottom: 10px;
          right: 10px;
          width: 100px;
          height: 100px;
        }
      }
    </style>
  </head>
  <body>
    <div id="ui-layer">
      <h1 class="text-2xl retro-text text-cyan-400">NEON FELINE FRONTIER</h1>
      <p class="text-sm text-pink-400">WASD to Move | SPACE to Fire</p>
      <p class="text-xs text-gray-400 mt-2">
        Socket Status: <span id="conn-status" class="text-red-500">OFFLINE</span>
      </p>
      <p class="text-xs text-gray-400">Cats in Grid: <span id="player-count">1</span></p>
    </div>

    <div id="chat-container">
      <div class="retro-panel">
        <h3 class="text-cyan-400 text-xs mb-2 font-bold tracking-widest">CHAT</h3>
        <div id="chat-messages"></div>
        <div class="flex gap-2">
          <input
            type="text"
            id="chat-input"
            class="retro-input text-xs"
            placeholder="Broadcast..."
            maxlength="100"
            autocomplete="off"
          />
          <button id="btn-send" class="retro-btn text-xs">üöÄ</button>
        </div>
      </div>
    </div>

    <div id="stats-container" style="position: absolute; bottom: 20px; left: 20px; pointer-events: auto; z-index: 100">
      <div class="retro-panel" style="padding: 8px; min-width: 200px">
        <h3 class="text-cyan-400 text-xs mb-2 font-bold tracking-widest">STATS</h3>
        <p class="text-xs text-gray-400">Your Score: <span id="your-score" class="text-pink-400">0</span></p>
        <div
          id="cooldown-bar"
          style="
            margin-top: 8px;
            height: 16px;
            background: rgba(255, 0, 222, 0.2);
            border: 1px solid #ff00de;
            position: relative;
          "
        >
          <div id="cooldown-fill" style="height: 100%; background: #ff00de; width: 0%; transition: width 0.1s"></div>
          <span
            style="
              position: absolute;
              top: 0;
              left: 50%;
              transform: translateX(-50%);
              color: white;
              font-size: 10px;
              line-height: 16px;
            "
            >YARN</span
          >
        </div>
      </div>
    </div>

    <div
      id="scoreboard-container"
      style="position: absolute; top: 20px; right: 319px; pointer-events: auto; z-index: 100; max-width: 250px"
    >
      <div class="retro-panel" style="padding: 8px">
        <h3 class="text-cyan-400 text-xs mb-2 font-bold tracking-widest">LEADERBOARD</h3>
        <div
          id="scoreboard-list"
          style="max-height: 200px; overflow-y: auto; scrollbar-width: thin; scrollbar-color: #ff00de transparent"
        >
          <!-- Scoreboard entries will be inserted here -->
        </div>
      </div>
    </div>

    <div id="mobile-controls"><div id="joystick"></div></div>

    <div id="minimap-container">
      <canvas id="minimapCanvas"></canvas>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
      let socket;

      // Initial setup for Socket.io
      try {
        if (typeof io !== 'undefined') {
          socket = io();
        } else {
          console.warn('Socket.io (io) is not defined. Ensure server.js is running.');
        }
      } catch (e) {
        console.error('Socket error:', e);
      }

      const canvas = document.getElementById('gameCanvas');
      const ctx = canvas.getContext('2d');
      const minimapCanvas = document.getElementById('minimapCanvas');
      const mctx = minimapCanvas.getContext('2d');

      const WORLD_SIZE = 50000;
      const PLAYER_SPEED = 6;

      const CAT_NAMES = [
        'Meow-tron',
        'Cyber-Whiskers',
        'Pixel-Paw',
        'Bit-Kitten',
        'Neon-Tabby',
        'Glitch-Cat',
        'Data-Pounce',
        'Synth-Claw',
        'Logic-Tail',
        'Laser-Mew',
        'Matrix-Mog',
        'Aero-Fluff',
      ];

      let players = {};
      let keys = {};
      let camera = { x: 0, y: 0 };
      let projectiles = [];
      let fish = [];
      let stunned = {};
      let scores = {};
      let lastFireTime = 0;
      let lastMovementDirection = { x: 1, y: 0 }; // Track last movement for yarn aiming
      const FIRE_COOLDOWN = 500;

      const localPlayer = {
        x: Math.random() * WORLD_SIZE,
        y: Math.random() * WORLD_SIZE,
        color: getRandomNeonColor(),
        direction: 1,
        skinType: Math.floor(Math.random() * 3),
        name: CAT_NAMES[Math.floor(Math.random() * CAT_NAMES.length)] + '-' + Math.floor(Math.random() * 99),
      };

      let joystickActive = false;
      let joystickData = { x: 0, y: 0 };

      if (socket) {
        socket.on('connect', () => {
          document.getElementById('conn-status').innerText = 'CONNECTED';
          document.getElementById('conn-status').className = 'text-green-400';
          // addChatMessage('SYSTEM', 'Uplink established.', '#00ff99');
          sendUpdate();
        });

        socket.on('disconnect', () => {
          document.getElementById('conn-status').innerText = 'DISCONNECTED';
          document.getElementById('conn-status').className = 'text-red-500';
          // addChatMessage('SYSTEM', 'Uplink severed.', '#ff0055');
        });

        // Handle incoming chat messages
        socket.on('chat-message', (msg) => {
          addChatMessage(msg.name, msg.text, msg.color);
        });

        socket.on('players-list', (data) => {
          for (let id in players) {
            if (!data[id]) delete players[id];
          }

          for (let id in data) {
            if (id === socket.id) continue;

            if (!players[id]) {
              players[id] = {
                ...data[id],
                targetX: data[id].x,
                targetY: data[id].y,
              };
            } else {
              players[id].targetX = data[id].x;
              players[id].targetY = data[id].y;
              players[id].name = data[id].name;
              players[id].color = data[id].color;
              players[id].direction = data[id].direction;
              players[id].skinType = data[id].skinType;
            }
          }
          updatePlayerCount();
        });

        socket.on('player-removed', (id) => {
          delete players[id];
          updatePlayerCount();
        });

        socket.on('projectiles-update', (data) => {
          projectiles = data;
        });

        socket.on('fish-update', (data) => {
          fish = data;
          // addChatMessage('SYSTEM', `new fish ${data}`, '#00ff99');
          console.log(data);
        });

        socket.on('scores-update', (data) => {
          scores = data;
        });

        socket.on('player-stunned', (data) => {
          stunned[data.playerId] = {
            until: data.until,
            immuneUntil: data.immuneUntil,
          };

          // if (data.playerId === socket.id) {
          //   addChatMessage('SYSTEM', "‚ö° You've been stunned!", '#ff0055');
          // }
        });

        // socket.on('fish-collected', (data) => {
        //   if (data.playerId === socket.id) {
        //     addChatMessage('SYSTEM', `üêü Fish collected! Score: ${data.newScore}`, '#00ff99');
        //   }
        // });
      }

      function sendUpdate() {
        if (socket && socket.connected) {
          socket.emit('player-update', {
            x: Math.round(localPlayer.x),
            y: Math.round(localPlayer.y),
            color: localPlayer.color,
            direction: localPlayer.direction,
            skinType: localPlayer.skinType,
            name: localPlayer.name,
          });
        }
      }

      function sendMessage() {
        const input = document.getElementById('chat-input');
        const text = input.value.trim();
        if (text && socket && socket.connected) {
          socket.emit('send-chat', {
            text: text,
            name: localPlayer.name,
            color: localPlayer.color,
          });
          // Echo the message locally
          addChatMessage(localPlayer.name, text, localPlayer.color);
          input.value = '';
        } else if (!socket || !socket.connected) {
          // addChatMessage('SYSTEM', 'Cannot send: Offline.', '#ff0055');
        }
      }

      function fireYarn() {
        const now = Date.now();

        if (now - lastFireTime < FIRE_COOLDOWN) {
          return;
        }

        if (stunned[socket?.id] && stunned[socket.id].until > now) {
          return;
        }

        lastFireTime = now;

        if (socket && socket.connected) {
          socket.emit('fire-yarn', {
            directionX: lastMovementDirection.x,
            directionY: 0,
            // directionY: lastMovementDirection.y,
          });
        }
      }

      function addChatMessage(name, text, color) {
        const container = document.getElementById('chat-messages');
        const div = document.createElement('div');
        div.className = 'chat-msg';

        // Sanitization (simple)
        const cleanName = name.replace(/</g, '&lt;');
        const cleanText = text.replace(/</g, '&lt;');

        div.innerHTML = `<span style="color:${color}; font-weight:bold;">[${cleanName}]</span>: ${cleanText}`;
        container.appendChild(div);

        // Auto-scroll to bottom
        container.scrollTop = container.scrollHeight;
      }

      function init() {
        resize();
        window.addEventListener('resize', resize);

        window.addEventListener('keydown', (e) => {
          // Ignore game controls if typing in chat
          if (document.activeElement.id === 'chat-input') {
            if (e.code === 'Enter') sendMessage();
            return;
          }
          keys[e.code] = true;
          // Fire yarn with Space
          if (e.code === 'Space') {
            fireYarn();
          }
          // Press 'Enter' to focus chat even if not clicking it
          if (e.code === 'Enter') document.getElementById('chat-input').focus();
        });

        window.addEventListener('keyup', (e) => (keys[e.code] = false));

        document.getElementById('btn-send').addEventListener('click', sendMessage);

        setupTouch();
        requestAnimationFrame(loop);

        // Regular state sync
        setInterval(sendUpdate, 100);

        // Welcome message
        addChatMessage('GRID', 'Welcome to the Frontier, ' + localPlayer.name, '#00f3ff');
      }

      function loop() {
        update();
        draw();
        drawMinimap();
        updateStatsUI();
        updateScoreboard();
        requestAnimationFrame(loop);
      }

      function updateStatsUI() {
        // Update score
        const yourScore = scores[socket?.id] || 0;
        document.getElementById('your-score').innerText = yourScore;

        // Update cooldown bar
        const now = Date.now();
        const cooldownRemaining = Math.max(0, FIRE_COOLDOWN - (now - lastFireTime));
        const cooldownPercent = (1 - cooldownRemaining / FIRE_COOLDOWN) * 100;
        document.getElementById('cooldown-fill').style.width = cooldownPercent + '%';
      }

      function updateScoreboard() {
        const scoreboardList = document.getElementById('scoreboard-list');
        if (!scoreboardList) return;

        // Create array of player scores with their names
        const playerScores = [];
        for (let playerId in players) {
          const player = players[playerId];
          const score = scores[playerId] || 0;
          playerScores.push({
            id: playerId,
            name: player.name || 'Unknown',
            score: score,
            color: player.color,
          });
        }

        // Add local player if not already in list
        if (socket?.id && !playerScores.find((p) => p.id === socket.id)) {
          playerScores.push({
            id: socket.id,
            name: localPlayer.name,
            score: scores[socket.id] || 0,
            color: localPlayer.color,
          });
        }

        // Sort by score (descending)
        playerScores.sort((a, b) => b.score - a.score);

        // Generate HTML
        let html = '';
        playerScores.forEach((player, index) => {
          const rank = index + 1;
          const isLocalPlayer = player.id === socket?.id;
          const highlightClass = isLocalPlayer ? 'highlight' : '';

          html += `
            <div class="scoreboard-entry ${highlightClass}">
              <span class="scoreboard-rank">#${rank}</span>
              <span class="scoreboard-name" style="color: ${player.color}">${player.name}</span>
              <span class="scoreboard-score">üêü ${player.score}</span>
            </div>
          `;
        });

        scoreboardList.innerHTML = html;
      }

      function update() {
        let dx = 0,
          dy = 0;

        const now = Date.now();
        const isStunned = stunned[socket?.id] && stunned[socket.id].until > now;

        if (!isStunned) {
          if (keys['ArrowUp'] || keys['KeyW']) dy -= 1;
          if (keys['ArrowDown'] || keys['KeyS']) dy += 1;
          if (keys['ArrowLeft'] || keys['KeyA']) dx -= 1;
          if (keys['ArrowRight'] || keys['KeyD']) dx += 1;
          if (joystickActive) {
            dx = joystickData.x;
            dy = joystickData.y;
          }

          if (dx !== 0 || dy !== 0) {
            if (dx !== 0) {
              // Track last movement direction for yarn aiming
              lastMovementDirection = { x: dx, y: dy };
            }
            if (!joystickActive) {
              const mag = Math.sqrt(dx * dx + dy * dy);
              dx /= mag;
              dy /= mag;
            }
            localPlayer.x = Math.max(0, Math.min(WORLD_SIZE, localPlayer.x + dx * PLAYER_SPEED));
            localPlayer.y = Math.max(0, Math.min(WORLD_SIZE, localPlayer.y + dy * PLAYER_SPEED));
            if (dx > 0) localPlayer.direction = 1;
            if (dx < 0) localPlayer.direction = -1;
          }
        }

        camera.x = localPlayer.x - canvas.width / 2;
        camera.y = localPlayer.y - canvas.height / 2;

        // Interpolate remote players
        for (let id in players) {
          const p = players[id];
          if (p.targetX !== undefined) {
            p.x += (p.targetX - p.x) * 0.15;
            p.y += (p.targetY - p.y) * 0.15;
          }
        }
      }

      function draw() {
        ctx.fillStyle = '#0f0a1e';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.save();
        ctx.translate(-camera.x, -camera.y);

        // Grid background
        ctx.beginPath();
        ctx.strokeStyle = 'rgba(255, 0, 222, 0.1)';
        for (let x = 0; x <= WORLD_SIZE; x += 100) {
          ctx.moveTo(x, 0);
          ctx.lineTo(x, WORLD_SIZE);
        }
        for (let y = 0; y <= WORLD_SIZE; y += 100) {
          ctx.moveTo(0, y);
          ctx.lineTo(WORLD_SIZE, y);
        }
        ctx.stroke();

        // Draw fish
        for (let f of fish) {
          drawFish(f);
        }

        // Draw remote players
        for (let id in players) {
          if (players[id].x !== undefined) {
            drawCat(players[id], stunned[id]);
          }
        }

        // Draw local player
        drawCat(localPlayer, stunned[socket?.id]);

        // Draw projectiles
        for (let proj of projectiles) {
          drawProjectile(proj);
        }

        ctx.restore();
      }

      function drawProjectile(proj) {
        console.log(proj);

        ctx.save();
        ctx.translate(proj.x, proj.y);

        // Calculate rotation based on projectile movement
        const rotation = Date.now() * 0.01;
        ctx.rotate(rotation);

        // Outer glow
        ctx.shadowBlur = 15;
        ctx.shadowColor = '#ff00de';

        // Main yarn ball
        ctx.fillStyle = '#ff00de';
        ctx.strokeStyle = '#00f3ff';
        ctx.lineWidth = 2;

        ctx.beginPath();
        ctx.arc(0, 0, 8, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();

        // Yarn strands pattern (rotating)
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 1.5;
        for (let i = 0; i < 3; i++) {
          const angle = (i / 3) * Math.PI * 2;
          ctx.beginPath();
          ctx.arc(0, 0, 6, angle, angle + Math.PI * 0.6);
          ctx.stroke();
        }

        // Inner highlight
        ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
        ctx.beginPath();
        ctx.arc(-2, -2, 2, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
      }

      function drawFish(f) {
        ctx.save();
        ctx.translate(f.x, f.y);

        ctx.fillStyle = '#ffcc00';
        ctx.strokeStyle = '#ff9900';
        ctx.lineWidth = 2;

        // Body
        ctx.beginPath();
        ctx.ellipse(0, 0, 12, 8, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();

        // Tail
        ctx.beginPath();
        ctx.moveTo(-12, 0);
        ctx.lineTo(-18, -6);
        ctx.lineTo(-18, 6);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();

        // Eye
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.arc(6, -2, 2, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
      }

      function drawMinimap() {
        mctx.clearRect(0, 0, minimapCanvas.width, minimapCanvas.height);
        const scale = minimapCanvas.width / WORLD_SIZE;
        mctx.strokeStyle = 'rgba(255, 0, 222, 0.2)';
        mctx.strokeRect(0, 0, minimapCanvas.width, minimapCanvas.height);

        for (let id in players) {
          const p = players[id];
          mctx.fillStyle = p.color;
          mctx.beginPath();
          mctx.arc(p.x * scale, p.y * scale, 2, 0, Math.PI * 2);
          mctx.fill();
        }

        mctx.fillStyle = '#ffffff';
        mctx.beginPath();
        mctx.arc(localPlayer.x * scale, localPlayer.y * scale, 3, 0, Math.PI * 2);
        mctx.fill();
      }

      function drawCat(p, stunnedState) {
        ctx.save();
        ctx.translate(p.x, p.y);

        const now = Date.now();
        const isStunned = stunnedState && stunnedState.until > now;
        const isImmune = stunnedState && stunnedState.immuneUntil > now && !isStunned;

        // Apply blinking transparency for immune cats
        if (isImmune) {
          const blinkSpeed = 0.009;
          const opacity = 0.1 + Math.abs(Math.sin(now * blinkSpeed)) * 0.5;
          ctx.globalAlpha = opacity;
        }

        // Label
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 12px "Courier New"';
        ctx.textAlign = 'center';
        ctx.fillText(p.name || '...', 0, -35);

        // Stun indicator
        if (isStunned) {
          ctx.fillStyle = '#ff0055';
          ctx.font = 'bold 14px "Courier New"';
          ctx.fillText('STUNNED', 0, -50);

          const alpha = 0.3 + Math.sin(now / 100) * 0.2;
          ctx.strokeStyle = `rgba(255, 0, 85, ${alpha})`;
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.arc(0, 0, 25, 0, Math.PI * 2);
          ctx.stroke();
        }

        ctx.scale(p.direction || 1, 1);
        ctx.fillStyle = p.color;
        ctx.strokeStyle = p.color;
        ctx.lineWidth = 2;

        // Ears
        ctx.beginPath();
        ctx.moveTo(-12, -12);
        ctx.lineTo(-12, -22);
        ctx.lineTo(-4, -12);
        ctx.moveTo(12, -12);
        ctx.lineTo(12, -22);
        ctx.lineTo(4, -12);
        ctx.fill();

        // Body
        if (p.skinType === 1) {
          ctx.fillRect(-12, -12, 24, 24);
        } else if (p.skinType === 2) {
          ctx.beginPath();
          ctx.moveTo(0, -15);
          ctx.lineTo(15, 10);
          ctx.lineTo(-15, 10);
          ctx.closePath();
          ctx.fill();
        } else {
          ctx.beginPath();
          ctx.arc(0, 0, 15, 0, Math.PI * 2);
          ctx.fill();
        }

        // Tail
        ctx.beginPath();
        ctx.moveTo(-15, 0);
        ctx.quadraticCurveTo(-25, -20, -15, -30);
        ctx.stroke();

        // Eyes
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(6, -4, 2, 0, Math.PI * 2);
        ctx.arc(-2, -4, 2, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
      }

      function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        minimapCanvas.width = 300;
        minimapCanvas.height = 300;
      }

      function getRandomNeonColor() {
        return ['#ff0055', '#00ff99', '#00ccff', '#cc00ff', '#ffcc00'][Math.floor(Math.random() * 5)];
      }
      function updatePlayerCount() {
        const count = 1 + Object.keys(players).length;
        document.getElementById('player-count').innerText = count;
      }

      function setupTouch() {
        const stick = document.getElementById('mobile-controls');
        const handle = document.getElementById('joystick');
        stick.addEventListener(
          'touchstart',
          (e) => {
            joystickActive = true;
            handleTouch(e);
          },
          { passive: false },
        );
        stick.addEventListener(
          'touchmove',
          (e) => {
            handleTouch(e);
          },
          { passive: false },
        );
        stick.addEventListener('touchend', () => {
          joystickActive = false;
          handle.style.transform = 'translate(-50%, -50%)';
          joystickData = { x: 0, y: 0 };
        });
        function handleTouch(e) {
          e.preventDefault();
          const t = e.targetTouches[0];
          const r = stick.getBoundingClientRect();
          const dx = t.clientX - (r.left + 75),
            dy = t.clientY - (r.top + 75);
          const dist = Math.sqrt(dx * dx + dy * dy);
          const limited = Math.min(dist, 50);
          const angle = Math.atan2(dy, dx);
          handle.style.transform = `translate(-50%, -50%) translate(${Math.cos(angle) * limited}px, ${Math.sin(angle) * limited}px)`;
          joystickData = { x: (Math.cos(angle) * limited) / 50, y: (Math.sin(angle) * limited) / 50 };
        }
      }

      window.onload = init;
    </script>
  </body>
</html>
